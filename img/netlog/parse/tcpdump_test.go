package parse

import (
	"bytes"
	"fmt"
	"io"
	"testing"

	"github.com/stretchr/testify/require"
	"github.com/ulmenhaus/env/img/netlog/models"
)

const (
	exampleDump = `\t0x0000:  0000 0001 0006 0242 0a01 0051 0000 0800  .......B...Q....
\t0x0010:  4500 0028 7997 4000 4006 ac89 0a01 0051  E..(y.@.@......Q
\t0x0020:  0a01 005d dd62 1388 51c4 a98b 0000 0000  ...].b..Q.......
\t0x0030:  5004 0000 aef6 0000                      P.......
`
	exampleDumpMisaligned = `\t0x0000:  0004 0001 0006 0242 ac12 0004 0000 0800  .......B........
\t0x0010:  4500 0045 50a7 4000 4011 91c9 ac12 0004  E..EP.@.@.......
\t0x0020:  ac1f 0002 98a0 0035 0031 587a 1c08 0100  .......5.1Xz....
\t0x0030:  0001 0000 0000 0000 0131 0130 0231 3803  .........1.0.18.
\t0x0040:  3137 3207 696e 2d61 6464 7204 6172 7061  172.in-addr.arpa
\t0x0050:  0000 0c00 01                             .....
`
	simplePingStream = `tcpdump: listening on any, link-type LINUX_SLL (Linux cooked), capture size 262144 bytes
18:32:26.886772 IP (tos 0x0, ttl 64, id 10483, offset 0, flags [DF], proto ICMP (1), length 84)
    localhost > localhost: ICMP echo request, id 5888, seq 1, length 64
\t0x0000:  0000 0304 0006 0000 0000 0000 0000 0800  ................
\t0x0010:  4500 0054 28f3 4000 4001 13b4 7f00 0001  E..T(.@.@.......
\t0x0020:  7f00 0001 0800 f6ea 1700 0001 2fde ba35  ............/..5
\t0x0030:  0000 0000 0000 0000 0000 0000 0000 0000  ................
\t0x0040:  0000 0000 0000 0000 0000 0000 0000 0000  ................
\t0x0050:  0000 0000 0000 0000 0000 0000 0000 0000  ................
\t0x0060:  0000 0000                                ....
18:32:26.886794 IP (tos 0x0, ttl 64, id 10484, offset 0, flags [none], proto ICMP (1), length 84)
    localhost > localhost: ICMP echo reply, id 5888, seq 1, length 64
\t0x0000:  0000 0304 0006 0000 0000 0000 0000 0800  ................
\t0x0010:  4500 0054 28f4 0000 4001 53b3 7f00 0001  E..T(...@.S.....
\t0x0020:  7f00 0001 0000 feea 1700 0001 2fde ba35  ............/..5
\t0x0030:  0000 0000 0000 0000 0000 0000 0000 0000  ................
\t0x0040:  0000 0000 0000 0000 0000 0000 0000 0000  ................
\t0x0050:  0000 0000 0000 0000 0000 0000 0000 0000  ................
\t0x0060:  0000 0000                                ....
`
)

var (
	exampleDumpAsHex           = []byte{0x00, 0x00, 0x00, 0x01, 0x00, 0x06, 0x02, 0x42, 0x0a, 0x01, 0x00, 0x51, 0x00, 0x00, 0x08, 0x00, 0x45, 0x00, 0x00, 0x28, 0x79, 0x97, 0x40, 0x00, 0x40, 0x06, 0xac, 0x89, 0x0a, 0x01, 0x00, 0x51, 0x0a, 0x01, 0x00, 0x5d, 0xdd, 0x62, 0x13, 0x88, 0x51, 0xc4, 0xa9, 0x8b, 0x00, 0x00, 0x00, 0x00, 0x50, 0x04, 0x00, 0x00, 0xae, 0xf6, 0x00, 0x00}
	exampleDumpMisalignedAsHex = []byte{0x00, 0x04, 0x00, 0x01, 0x00, 0x06, 0x02, 0x42, 0xac, 0x12, 0x00, 0x04, 0x00, 0x00, 0x08, 0x00, 0x45, 0x00, 0x00, 0x45, 0x50, 0xa7, 0x40, 0x00, 0x40, 0x11, 0x91, 0xc9, 0xac, 0x12, 0x00, 0x04, 0xac, 0x1f, 0x00, 0x02, 0x98, 0xa0, 0x00, 0x35, 0x00, 0x31, 0x58, 0x7a, 0x1c, 0x08, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x31, 0x01, 0x30, 0x02, 0x31, 0x38, 0x03, 0x31, 0x37, 0x32, 0x07, 0x69, 0x6e, 0x2d, 0x61, 0x64, 0x64, 0x72, 0x04, 0x61, 0x72, 0x70, 0x61, 0x00, 0x00, 0x0c, 0x00, 0x01}
	simplePingStreamFrame0     = []byte{0x00, 0x00, 0x03, 0x04, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x45, 0x00, 0x00, 0x54, 0x28, 0xf3, 0x40, 0x00, 0x40, 0x01, 0x13, 0xb4, 0x7f, 0x00, 0x00, 0x01, 0x7f, 0x00, 0x00, 0x01, 0x08, 0x00, 0xf6, 0xea, 0x17, 0x00, 0x00, 0x01, 0x2f, 0xde, 0xba, 0x35, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
	simplePingStreamFrame1     = []byte{0x00, 0x00, 0x03, 0x04, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x45, 0x00, 0x00, 0x54, 0x28, 0xf4, 0x00, 0x00, 0x40, 0x01, 0x53, 0xb3, 0x7f, 0x00, 0x00, 0x01, 0x7f, 0x00, 0x00, 0x01, 0x00, 0x00, 0xfe, 0xea, 0x17, 0x00, 0x00, 0x01, 0x2f, 0xde, 0xba, 0x35, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
)

func TestParseTCPDumpHexDump(t *testing.T) {
	p, err := NewTCPDumpParser()
	require.NoError(t, err)
	cases := []struct {
		name     string
		dump     string
		expected []byte
	}{
		{
			name:     "aligned",
			dump:     exampleDump,
			expected: exampleDumpAsHex,
		},
		{
			name:     "misaligned",
			dump:     exampleDumpMisaligned,
			expected: exampleDumpMisalignedAsHex,
		},
	}
	for i, tc := range cases {
		t.Run(fmt.Sprintf("%d-%s", i, tc.name), func(t *testing.T) {
			actual, err := p.ParseHexDump([]byte(tc.dump))
			require.NoError(t, err)
			require.Equal(t, tc.expected, actual)
		})
	}
}

func TestParseStream(t *testing.T) {
	p, err := NewTCPDumpParser()
	require.NoError(t, err)
	cases := []struct {
		name     string
		stream   string
		expected []EthernetEvent
		expErr   error
	}{
		{
			name:   "simple ping stream",
			stream: simplePingStream,
			expected: []EthernetEvent{
				{
					Frame: models.IEEEFrame(simplePingStreamFrame0),
				},
				{
					Frame: models.IEEEFrame(simplePingStreamFrame1),
				},
			},
			expErr: io.EOF,
		},
	}
	for i, tc := range cases {
		t.Run(fmt.Sprintf("%d-%s", i, tc.name), func(t *testing.T) {
			buff := bytes.NewBuffer([]byte(tc.stream))
			eventChan, errChan := p.ParseStream(buff)
			actual := []EthernetEvent{}
			for event := range eventChan {
				actual = append(actual, event)
			}
			err = <-errChan
			require.Equal(t, tc.expErr, err)
			require.Equal(t, tc.expected, actual)
		})
	}
}
